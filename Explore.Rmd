---
title: "Cleaning COVID-19 Data from Johns Hopkins"
author: "Bill Kayser"
output:
  html_notebook: 
    fig_height: 6
    fig_width: 12
    toc: yes
  html_document: default
  pdf_document: 
    fig_height: 4
    fig_width: 7
    toc: yes
echo: TRUE

---

Initialize the Notebook loading the following required libraries. 

```{r results='hide', message=F}
library(tidyverse)
library(scales)
theme_set(theme_light())
source('utils.R')
```


<style type="text/css">
.table {
    width: inherit;
    max-width: 100%;
    margin-bottom: 20px;
}
.math.display {
  font-size: 28px;
}
</style>

# Load Datasets

We are pulling in data from the Johns Hopkins COVID-19 repository as well as world population data from wpp2019 and US Census information on county populations

### COVID-19 Data

Let's update the CV data directly from the Johns Hopkins git repo.  The first thing to do is check for any daily updates by updating the git submodule:

```{r}
system('git submodule update --remote COVID-19')
```

Load the timeseries data.  We'll need to convert the table from a wide format where the time series is in columns to a narrow format where each observation is a single datapoint for a day.

### Load Timeseries Data

```{r, echo=T}
cases <- read_and_clean('COVID-19/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_US.csv')
deaths <- read_and_clean('COVID-19/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_US.csv')
countries.cases <- read_and_clean('COVID-19/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv')
countries.deaths <- read_and_clean('COVID-19/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv')
```

### Load Census Data

This is how you could get data directly using the US Census bureau APIs but the data appears to be too fine grained.  We can use this later if we need more detailed census information.

```r
get_estimates(product="population", key=Sys.getenv('CENSUS_KEY'))
```

For now I'm just going to use some data I picked up off the census web site in the form of 2019 population estimates by county, and a very old file with square miles for all but about 25 counties.

```{r}
regions <- c('Northeast', 'Midwest', 'South', 'West')
divisions <- c('N Atlantic', 'Mid Atlantic', 'E North Ctrl', 'W North Ctrl', 'S Atlantic', 'E South Ctrl', 'W South Dtrl', 'Mountain', 'Pacific')

geographic_data <- prep_geographic_data(read.csv('data/county_area.csv', skip=7)) 

population_data <- read.csv('https://www2.census.gov/programs-surveys/popest/datasets/2010-2019/counties/totals/co-est2019-alldata.csv') %>% 
  mutate(Region = as.factor(regions[REGION]),
         Division = as.factor(divisions[DIVISION]),
         FIPS=as.integer(str_c(STATE,sprintf('%0.3i', COUNTY)))) %>%
  left_join(geographic_data, by=c(STNAME='State', CTYNAME='County')) %>%
  select(Region,
         State=STNAME,
         Division,
         FIPS,
         CountyCode=COUNTY,
         CTYNAME,
         Population=POPESTIMATE2019,
         Annual.Deaths=DEATHS2019, 
         Area) %>%
  mutate(Population.Density = round(Population / Area, 3)) %>%
   as_tibble()

counties <- filter(population_data, CountyCode > 0) %>% select(-State, -CTYNAME)
states <- filter(population_data, CountyCode == 0) %>% select(-CountyCode)
```

### Load CovidTracking data

This site has an aggregation of data about testing.  It's pretty messy data but we can join what there is to state level historical data.

```{r}
state_abbreviations <- read.csv('data/state_abbrev.csv') %>% select(State, State.Code=Code)
covid.testing <- read.csv('https://covidtracking.com/api/v1/states/daily.csv') %>% 
  as_tibble() %>%
  left_join(state_abbreviations, by=c(state='State.Code')) %>%
  rename(State.Code=state, Date=date) %>%
  mutate(Date = as.Date(as.POSIXct(strptime(as.character(Date), format='%Y%m%d'))))
```

# Prepare Data

### Join Tables

Start combining tables with external data.  Also invokes `calculate_differentials()` which adds new variables which are the single day and 3 day changes to Cases and Deaths, in addition to a Growth3 variable which is the average daily growth rate of Cases and Deaths over a three day period.

Join the US confirmed cases to deaths and census population data.  Create a single table, `cvdata.us`.

```{r}
cvdata.us <- left_join(cases, 
                       select(deaths, Key, Date, Count),
                       by=c('Key', 'Date')) %>%
  rename(Cases = Count.x,
         Deaths = Count.y) %>%
  left_join(counties, by='FIPS') %>% 
  left_join(state_abbreviations, by='State') %>% 
  filter(!is.na(Region)) %>%
  mutate(State = as.factor(State), 
         County = as.factor(County)) %>%
  calculate_differentials(c('Cases', 'Deaths'))
```

Join the cases and deaths for country data into a single table, `cvdata.i18n`.

```{r}
populations <- read.csv('data/population.csv', skip = 3, stringsAsFactors = F) %>% select(Country = Country.Name, Population = X2018)
populations[populations$Country == 'Korea, Rep.', 'Country'] = 'Korea, South'
populations[populations$Country == 'United States', 'Country'] = 'US'
populations[populations$Country == 'Russian Federation', 'Country'] = 'Russia'
populations[populations$Country == 'Iran, Islamic Rep.', 'Country'] = 'Iran'
populations[populations$Country == 'Taiwan*', 'Country'] = 'Taiwan'
populations[nrow(populations)+1, ] <- list('China, Hubei', 58.5e6) # 2015 National bureau of stats, China

cvdata.i18n <- 
  countries.cases %>%
  left_join(populations, by='Country') %>%
  left_join(select(countries.deaths, Key, Date, Deaths=Count),
            by=c('Key', 'Date')) %>%
  rename(Cases=Count) %>% 
  calculate_differentials(c('Cases', 'Deaths'))
  
```

### Derive Additional Tables

Group data by state and save into table `cvdata.us.by_state`.

```{r, message=F}
cvdata.us.by_state <- cvdata.us %>%
  group_by(State, Date) %>%
  summarize(Cases = sum(Cases),
            Key = first(State),
            Deaths = sum(Deaths))%>%
  ungroup(State, Date) %>%
  left_join(states, by=c('State')) %>% mutate(State = as.factor(State)) %>%
  filter(!is.na(Region))  %>%
  # Join with the testing data
  left_join(covid.testing, by=c('State', 'Date')) %>%
  select(-hash, -dateChecked, -fips, -CTYNAME) %>% 
  calculate_differentials(c('Cases', 'Deaths')) %>%
  mutate(State.Code = fct_inorder(as.factor(State.Code)),
         State = fct_inorder(as.factor(State)),
         Infection.Rate = Cases.Diff * 1000000 / Population,
         Death.Rate = Deaths.Diff * 1000000 / Population)
```

Create a single timeseries table just for Italy called `italy`.

```{r}
italy <- cvdata.i18n %>%
  filter(Country == 'Italy') %>%
  select(-Key, -Lat, -Long, -Country) 

```
# Save the Data

```{r echo=T}
saveRDS(cvdata.us, 'data/cvdata.us.RDS')
saveRDS(cvdata.us.by_state, 'data/cvdata.us.by_state.RDS')
saveRDS(cvdata.i18n, 'data/cvdata.i18n.RDS')
```

# Data Exploration

```{r include=F}
knitr::opts_chunk$set(echo=F)
```

For the US Data I'm just showing a few states so the plots are more readable.  This is just preliminary exploration as I get to know the data and clean it for other purposes.

Let's first set up some parameters for the graph's X axis.

```{r}
start_date <- mdy('02/26/2020')
end_date <- max(cvdata.us$Date)
breaks <- seq(end_date,
              start_date,
              by="-1 week") %>% rev()
if (breaks[1] != start_date) {
  breaks <- c(breaks[1]-days(7), breaks)
  start_date <- breaks[1]
}
```

### Top Counties Infected

```{r}
cvdata.us %>%
  filter(!is.na(Division) & Date == end_date) %>%
  arrange(desc(Cases.Per100K)) %>%
  select(Key, Cases.Per100K, Deaths) %>%
  top_n(25) %>% knitr::kable()
```

### Reporting Anomalies

Consider the growth in deaths and cases, county by county, on each day of the week when there are at least 100 active confirmed cases.

```{r}
cvdata.daily <- cvdata.us %>%
  filter(Cases > 100) %>%
  mutate(day.of.week = factor(strftime(Date, '%A'), levels = c('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday')),
         Cases.Growth = Cases.Diff / Cases,
         Deaths.Growth = ifelse(Deaths == 0, 0, Deaths.Diff / Deaths))
```

What is the typical change in Confirmed Cases and Deaths on any day of the week?

```{r}
group_by(cvdata.daily, day.of.week) %>%
  summarize(Cases.Growth.Mean = percent(mean(Cases.Growth)),
            Deaths.Growth.Mean = percent(mean(Deaths.Growth, na.rm=T)))

ggplot(cvdata.daily) +
  aes(x=day.of.week, y = Cases.Growth) +
  geom_boxplot() +
  xlab('Day of Week') +
  ylab('Growth in Cases') +
  scale_y_continuous(labels=percent)
```


### Top Countries infected

```{r top_countries, fig.width=5}
max_date <- max(cvdata.i18n$Date)
countries <- 
  filter(cvdata.i18n, Date == max_date) %>%
  arrange(desc(Cases)) %>% 
  head(10)

ggplot(countries) +
  aes(fill=Country,
      x=Country,
      y=Cases) +
  geom_col(show.legend=F) +
  scale_y_continuous(labels=comma) +
  xlab(NULL)
```

### Confirmed Cases Grouped by State

```{r echo=F}
g <- cvdata.us.by_state %>%
  filter((State %in% c('New York', 'Oregon', 'Indiana', 'California'))) %>%
  mutate(State=factor(as.character(State))) %>%
  arrange(State, Date) %>%
  filter( Cases > 0) %>%
  ggplot() +
  aes(Date, Cases, color=State) +
  ggtitle('COVID-19 Confirmed Cases by States') +
  geom_line() + 
  xlab(NULL) +
  coord_cartesian(xlim=c(start_date, end_date)) +
  scale_x_date(breaks=breaks, date_labels = '%m/%d', date_minor_breaks='1 day')

g + scale_y_continuous(labels=comma) 
g + scale_y_log10(labels=comma) + labs(subtitle="Log Scale")
```

### Deaths, grouped by State.

```{r, echo=F}
g <- cvdata.us.by_state %>%
  filter((State %in% c('New York', 'Oregon', 'Indiana', 'California'))) %>%
  mutate(State=fct_drop(State)) %>%
  arrange(State, Date) %>%
  filter( Deaths > 0) %>%
  ggplot() +
  aes(Date, Deaths, color=State) + 
  geom_line() + 
  ggtitle('COVID-19 Deaths by State') +
  xlab(NULL) +
  coord_cartesian(xlim=c(start_date, end_date)) +
  scale_x_date(breaks=breaks, date_labels = '%m/%d', date_minor_breaks='1 day')

g + scale_y_continuous(labels=comma) 
g + scale_y_log10(labels=comma) + labs(subtitle = 'Log Scale') 

```

### Change in Confirmed Cases

This plot shows the day to day change in confirmed cases.  This is important because it will tell us when we hit that peak in infections, the top of the curve that we are trying to 'flatten'.  This peak occurs when the line crosses over the X axis into negative territory.

Right now you can see New York is a long way from that but the LOESS trend line shows it starting to trend downward.


```{r echo=F}
g <- cvdata.us %>%
  filter(State %in% c('New York', 'Oregon', 'Indiana', 'California')) %>%
  mutate(State = fct_drop(State)) %>%
  group_by(State, Date) %>%
  summarize(Cases.Diff3 = sum(Cases.Diff3)) %>%
  arrange(State, Date) %>%
  ggplot() +
  geom_line() + 
  geom_smooth(method='loess', span=0.2, size=0.5, linetype=3) +
  ggtitle('COVID-19 Confirmed Cases Day to Day Change, by States',
          subtitle = str_c("Reported data through ", format(max(cvdata.us$Date), "%B %d, %Y"))) +
  aes(Date, Cases.Diff3, color=State) +
  ylab("Daily Increase") +
  xlab(NULL)  +
  coord_cartesian(xlim=c(start_date, end_date)) +
  scale_x_date(breaks=breaks, date_labels = '%m/%d', date_minor_breaks='1 day')
g

```

```{r}
cvdata.us.by_state %>%
  filter(State %in% c('Arizona', 'Oregon', 'Indiana', 'California', 'New York')) %>%
  mutate(State = fct_drop(State)) %>%
  arrange(State, Date) %>%
  ggplot() +
  geom_line() + 
  #geom_smooth(method='loess', span=0.2, size=0.5, linetype=3) +
  ggtitle('COVID-19 Rate of Deaths Per Million, by States',
          subtitle = str_c("Reported data through ", format(max(cvdata.us$Date), "%B %d, %Y"))) +
  aes(Date, Death.Rate, color=State) +
  ylab("Daily Increase, per 1M people") +
  xlab(NULL)  +
  coord_cartesian(xlim=c(start_date, end_date)) +
  scale_x_date(breaks=breaks, date_labels = '%m/%d', date_minor_breaks='1 day')

```


### International Cases

```{r fig.width=6}
d0 <- filter(cvdata.i18n, Deaths >= 5 & Country %in% c("China, Hubei", "Spain", "France", "Germany","Iran", "Italy", "Korea, South", "United Kingdom", "US")) %>%
  mutate(Country = as.character(Country)) %>%
  filter(!is.na(Population))

d1 <- split(d0, d0$Country)
d2 <- lapply(d1, function(table) {
  table$Day <- 1:nrow(table)
  table
})

labels <- lapply(d2, tail, 1) %>% bind_rows()

country_data <- bind_rows(d2)

g <- ggplot(country_data) +
  aes(x=Day, color=Country) +
  geom_line(show.legend = F) +
  geom_text(data=labels, 
            mapping=aes(label=Country),
            show.legend = F,
            nudge_x = 0.5,
            check_overlap = F,
            size=3,
            hjust = 0) +
  coord_cartesian(xlim=c(0, max(labels$Day) + 15)) +
  ggtitle(paste0("National Trends as of ",format(end_date, "%B%e, %Y")), subtitle="Plotted individually from the first day of 5 recorded deaths") +
  xlab("Days Since First 24 Deaths") +
  facet_wrap('Country')

g + aes(y=Cases.Growth3) +
  ylab("Daily Increase in Cases") +
  scale_y_continuous(labels=percent) 

g + aes(y=Cases) + 
  ylab("Confirmed Cases")  +
  scale_y_continuous(labels=comma) 

g + aes(y=Deaths.Per100K) + 
  ylab("Deaths Per 100K Population") +
  scale_y_continuous(labels=comma) 

```


### State by State Confirmed Cases

```{r, fig.width=6, fig.height=6}
today <- filter(cvdata.us) %>%
  filter(Date == end_date & !is.na(Region) & Population > 500) %>%
  mutate(Cases.Rate = 1000000 * Cases / Population) 

averages.by_state <- tapply(today$Cases.Rate, today$State.Code, mean) %>% sort() %>% rev()
today <- mutate(today, State.Code = fct_relevel(State.Code, names(averages.by_state)))

ggplot(today) +
  aes(x = State.Code, y = Cases.Rate, fill = Region) +
  coord_flip(ylim=c(0,2000)) +
  geom_boxplot() +
ggtitle("")
```

### Infections Per Capita

Let's chart the current confirmed cases and deaths as a percentage of population.

```{r}
last_date <- max(cvdata.us.by_state$Date)

cvdata.us.by_state %>%
  filter(Date == last_date) %>%
  mutate(Infections.Per.100_000 = round(100000 * Cases / Population),
         Deaths.Per.100_000 = round(100000 * Deaths / Population, 1)) %>%
  select(State, Infections.Per.100_000, Deaths.Per.100_000) %>%
  arrange(desc(Infections.Per.100_000)) %>%
  head(10)

```

### Infection Rate by Region

```{r fig.width=5}
data <- cvdata.us.by_state %>% filter(Date == last_date)

ggplot(data) +
  aes(x=Division, y=Deaths.Per100K, fill=Division) +
  geom_boxplot() +
#  scale_y_log10(labels=comma) +
#  scale_x_discrete(labels=NULL) +
  xlab('Region') +
  ggtitle('Deaths Per 100K, by Region')
```


### Report on Lake Placid

Essex and Franklin counties seem to be closest.

```{r, fig.height=5}
our_counties <- filter(cvdata.us, 
                     (State == "New York" & County %in% c('Essex', 'Franklin', 'Clinton')) |
                     (State == "Indiana" & County %in% c('Hamilton')) |                       
                       (State == "California" & County %in% c('Contra Costa')) |
                     (State == "Arizona" & County %in% c('Maricopa')) |
                       (State == "Oregon" & County %in% c('Clackamas', 'Multnomah', 'Washington')))
labels <- filter(our_counties, Date == last_date)

g <- ggplot(our_counties) +
  aes(x=Date, y=Cases.Per100K, color=County) +
  xlab(NULL)  +
  coord_cartesian(xlim=c(mdy('03/15/2020'), end_date)) +
  ggtitle('Kayser Family Counties',
          subtitle = str_c("Reported data through ", format(max(cvdata.us$Date), "%B %d, %Y"))) +
  geom_line(aes(linetype=State)) + 
  geom_label(data=labels, aes(label=Key), hjust='right', show.legend=F, nudge_x = -1) +
  scale_x_date(breaks=breaks, date_labels = '%m/%d', date_minor_breaks='1 day')

g +
  aes(y = Cases.Per100K) +
  ylab("Confirmed Cases per 100K Population")

g +
  aes(y = Cases) +
  ylab("Confirmed Cases")
```




```{r}
all_counties <- cvdata.us %>%
  filter(!is.na(Division) & Date == end_date) %>%
  arrange(desc(Cases.Per100K)) %>%
  select(Key, Cases.Per100K) 

LP.Cases.Per100K <- filter(our_counties, Date == last_date) %>% 
  group_by(State) %>%
  summarize(Deaths = sum(Deaths),
            Cases = sum(Cases),
            Population = sum(Population)) %>%
  ungroup() %>%
  mutate(Cases.Per100K = Cases * 100000 / Population)

ranking <- round(sum(all_counties$Cases.Per100K <= LP.Cases.Per100K$Cases.Per100K[1]) / nrow(all_counties) * 100, 1)
median_rate <- median(all_counties$Cases.Per100K)
```

Total deaths to date in all three counties: `r LP.Cases.Per100K$Deaths`.

Total cases per 100K people: `r round(LP.Cases.Per100K$Cases.Per100K, 1)`

# Scatter Plots

Population Density vs. Infection Rate
```{r}
current_data <- filter(cvdata.us, Date == last_date & !is.na(Population.Density)) %>%
  mutate(Deaths.Per100K = Deaths * 100000 / Population)
ggplot(current_data) +
  aes(x=Cases.Diff3.Per100K) +
  geom_histogram(bins=400) +
  coord_cartesian(xlim=c(-10, 50))

ggplot(filter(current_data, Deaths.Per100K > 0)) +
  aes(x=Population.Density, y=Deaths.Per100K, show.legend=F) +
  geom_point(size=0.2) +
  geom_smooth(method='loess', color='red', size=0.5) +
  scale_y_log10(labels=comma) + 
  scale_x_log10() 
```

# Prediction


```{r fig.width=6}

d0 <- filter(cvdata.us.by_state, Cases > 100 & Cases.Growth3 > 0.010 & State %in% c("New York", "Oregon", "California", "New Jersey", "Arizona", "Indiana")) %>%
  mutate(State = fct_drop(State))

d1 <- group_by(d0, State) %>%
  summarize(Cases.Growth3 = max(Cases.Growth3))

sd0 <- semi_join(d0, d1, by=c('State', 'Cases.Growth3'))

start_dates <- sd0$Date
names(start_dates) <- sd0$State

d3 <- split(d0, d0$State)

# Filter the dates of each country to include only dates after the peak growth in cases occur.
d4 <- lapply(d3, function(table) {
  state <- table$State[1]
  t <- filter(table, Date >= start_dates[state])
  # Index this remaining data by Day, starting with the value Day = 1.
  t$Day <- 1:nrow(t)
  t
})

labels <- lapply(d4, tail, 1) %>% bind_rows()

# Rejoin the data
state_data <- bind_rows(d4)

g <- ggplot(state_data) +
  aes(x=Day, color=State) +
  geom_line(show.legend = F) +
  geom_text(data=labels, 
            mapping=aes(label=State),
            show.legend = F,
            nudge_x = 0.5,
            check_overlap = F,
            size=4,
            hjust = 0) +
  coord_cartesian(xlim=c(0, max(labels$Day) + 15)) +
  ggtitle(paste0("National Trends as of ",format(end_date, "%B%e, %Y")), subtitle="Plotted individually from the first day of 5 recorded deaths") +
  xlab("Days Since First 24 Deaths") +
  facet_wrap('State') +
  theme(strip.text.x = element_text(face='bold', size=12))

g + aes(y=Cases.Growth3) +
  ylab("Daily Increase in Cases") +
  geom_smooth(method='glm', size=0.5, color='black', se=F, formula= y ~ x) +
  scale_y_continuous(labels=percent) 
# 
# g + aes(y=Cases) + 
#   ylab("Confirmed Cases")  +
#   scale_y_continuous(labels=comma) 
# 
# g + aes(y=Deaths.Per100K) + 
#   ylab("Deaths Per 100K Population") +
#   scale_y_continuous(labels=comma) 

```



```{r fig.width=6}

# Step 0: Filter the left and right edge of the timeseries
countries.filtered <- filter(cvdata.i18n, Cases > 100 & Country %in% c("China, Hubei", "Spain", "France", "Germany","Iran", "Italy", "Korea, South", "United Kingdom", "US")) %>%
  mutate(Country = as.character(Country)) %>%
  filter(!is.na(Population))

peak_growth <- 
  semi_join(countries.filtered, 
            group_by(countries.filtered, Country) %>% summarize(Cases.Growth3 = max(Cases.Growth3)),
            by=c('Country', 'Cases.Growth3')) %>%
  select(Country, Date)

target_growth <- 
  filter(countries.filtered, Cases > 1000 & Cases.Growth3 < 0.014) %>%
  group_by(Country) %>%
  summarize(Date = min(Date))

start_dates <- peak_growth$Date
names(start_dates) <- peak_growth$Country

end_dates <- target_growth$Date
names(end_dates) <- target_growth$Country

# Split the table of countries into separate tables per country
countries.list <- split(countries.filtered, countries.filtered$Country)

# Filter the dates of each country to include only dates after the peak growth in cases occur.
countries.pred_window <- lapply(countries.list, function(table) {
  country <- table$Country[1]
  t <- table[table$Date >= start_dates[country] & 
               (is.na(end_dates[country]) | table$Date < end_dates[country]),]
  # Index this remaining data by Day, starting with the value Day = 1.
  t$Day <- 1:nrow(t)
  t
})

# Let's predict the peak
extrapolate.lm <- function(df) {
  t0 <- min(df$Date) 
  model <- tail(df, 20) %>%
    lm(formula = Cases.Growth3 ~ Day)
  x_intercept <- ceiling(-model$coefficients[1]/model$coefficients[2])
  prediction <- tibble(Country = df$Country[1],
                       Day = 0:x_intercept)
  p <- predict(model, prediction, se.fit = T)
  prediction$Cases.Growth3 <- p$fit
  prediction$Date <- t0 + days(round(prediction$Day))
  prediction$Day.Upper <- prediction$Day + p$se.fit
  prediction$Day.Lower <- prediction$Day - p$se.fit
  prediction$Date.Upper <- t0 + ceiling(prediction$Day.Upper)
  prediction$Date.Lower <- t0 + floor(prediction$Day.Lower)
  return(prediction)
}

predictions.list <-lapply(countries.pred_window, extrapolate.lm)
predictions <- bind_rows(predictions.list)
predictions.target_day <- lapply(predictions.list, tail, 1) %>% bind_rows() %>%
  mutate(Label = format(Date, "Peak cases %b %e"))


# Rejoin the data
country_data <- lapply(countries.list, function(table) {
  country <- table$Country[1]
  t <- filter(table, Date >= start_dates[country])
  t$Day <- 1:nrow(t)
  t
}) %>% bind_rows()

ggplot(country_data) +
  aes(x=Day, y=Cases.Growth3, color=Country) +
  geom_line(show.legend = F) +
  geom_line(data=predictions, color='black', size=0.5, linetype=3) +
  geom_vline(data=predictions.target_day, aes(xintercept = Day), color='darkgreen', size=0.5, alpha=0.5) +
  geom_label(data=predictions.target_day, aes(label = Label, x = Day), y = 0.25, color='darkgreen', size=3) +
  scale_y_continuous(labels=percent) +
  facet_wrap('Country') +
  theme(strip.text.x = element_text(face='bold', size=12)) +
  ggtitle(paste0("National Trends as of ",format(end_date, "%B%e, %Y")), subtitle="Plotted individually from the first day of 5 recorded deaths") +
  xlab("Days Since First 24 Deaths") +
  ylab("Daily Increase in Cases")
  
```



